#' BJSM Method for interim analysis and final analysis of group sequential trial design
#'
#' After obtain real trial data, this function can be used to decide which arm to drop for an interim analysis or provide a full analysis for a final analysis
#'
#'
#' @param data data should be in the same format as the simulated data generated by function `data_gen_group_seq_1step` and `data_gen_group_seq_2step`, with 8 columns:
#' time.1st.trt (first treatment starts time), time.1st.resp (first response time), time.2nd.trt (second treatment starts time), time.2nd.resp (second response time),
#' trt.1st (treatment arm for first treatment), resp.1st (response for first treatment), trt.2nd (treatment arm for second treatment), resp.2nd (response for second
#' treatment) data yet to be observed should be marked as "NA"
#' @param rule.type whether this trial is designed as a 1 step rule test  (`rule.type = 1`) or 2 step rule test (`rule.type = 2`)
#' @param interim whether user is analyzing an interim analysis via BJSM (interim = TRUE) or an final analysis via BJSM (interim = FALSE)
#' @param drop_threshold only assign value to this parameter when `rule.type = 1` and `interim = TRUE` a number between 0 and 1, if the posteriors probability of a treatment having the smallest response rate is bigger than the `drop_threshold`, this treatment will be dropped at that update. Default value is 0.5
#' @param drop_threshold_large only assign value to this parameter when `rule.type = 2` and `interim = TRUE`. a number between 0 and 1. Default value is 0.5
#' @param drop_threshold_small only assign value to this parameter when `rule.type = 2` and `interim = TRUE`. a number between 0 and 1. Default value is 0.5. See the details section for more explanation
#' @param NUM_ARMS number of treatment arms
#' @param pi_prior.a parameter a of the prior distribution for pi_1K, a vector with three values, one for each treatment. Please check the `Details` section for more explanation
#' @param pi_prior.b parameter b of the prior distribution  for pi_1K, a vector with three values, one for each treatment. Please check the `Details` section for more explanation
#' @param beta0_prior.a parameter a of the prior distribution for linkage parameter beta0
#' @param beta0_prior.b parameter b of the prior distribution  for linkage parameter beta0
#' @param beta1_prior.a parameter a of the prior distribution for linkage parameter beta1
#' @param beta1_prior.c parameter b of the prior distribution for linkage parameter beta1
#' @param n_MCMC_chain number of MCMC chains, default to 1. If this is set to a number more than 1
#' @param BURN.IN number of burn-in iterations for MCMC
#' @param MCMC_SAMPLE number of iterations for MCMC
#' @param pi_prior_dist prior distribution for pi, user can choose from gamma, beta, pareto
#' @param beta0_prior_dist prior distribution for beta0, user can choose from gamma, beta, pareto
#' @param beta1_prior_dist prior distribution for beta1, user can choose from gamma, beta, pareto
#' @param ci coverage probability for credible intervals, default = 0.95. only assign value to this parameter when `interim = FALSE`.
#' @param DTR, if TRUE, will also return the expected response rate of dynamic treatment regimens. default = TRUE. only assign value to this parameter when `interim = FALSE`.

#'
#' @details
#' (paper provided in the reference section, section 2.2.2 Bayesian decision rules. drop_threshold_large and drop_threshold_small are corresponding to `\tau_l` and `\phi_l` respectively {need to check with Kelley})

#' @example
#' mydata = readRDS("data/patient_entry.rds")
#'
#' result1 = group_seq(data = mydata, rule.type = 1, interim = TRUE, drop_threshold=0.5, NUM_ARMS = 3, pi_prior_dist = "beta", pi_prior.a =  c(0.4,0.4,0.4), pi_prior.b = c(1.6, 1.6, 1.6), beta0_prior_dist = "beta",
#' beta0_prior.a = 1.6, beta0_prior.b = 0.4, beta1_prior_dist = "pareto", beta1_prior.a = 3, beta1_prior.c = 1, MCMC_SAMPLE = 60000, BURN.IN = 10000,
#' n_MCMC_chain = 1)
#'
#' result2 = group_seq(data = mydata, rule.type = 2, interim = TRUE, drop_threshold_large=0.5, drop_threshold_small = 0.4, NUM_ARMS = 3, pi_prior_dist = "beta", pi_prior.a =  c(0.4,0.4,0.4), pi_prior.b = c(1.6, 1.6, 1.6), beta0_prior_dist = "beta",
#' beta0_prior.a = 1.6, beta0_prior.b = 0.4, beta1_prior_dist = "pareto", beta1_prior.a = 3, beta1_prior.c = 1, MCMC_SAMPLE = 60000, BURN.IN = 10000,
#' n_MCMC_chain = 1)
#'
#' mydata = readRDS("data/patient_entry_full.rds")
#' result3 = group_seq(data = mydata, rule.type = 2, interim = FALSE, NUM_ARMS = 3, pi_prior_dist = "beta", pi_prior.a =  c(0.4,0.4,0.4), pi_prior.b = c(1.6, 1.6, 1.6), beta0_prior_dist = "beta",
#' beta0_prior.a = 1.6, beta0_prior.b = 0.4, beta1_prior_dist = "pareto", beta1_prior.a = 3, beta1_prior.c = 1, MCMC_SAMPLE = 60000, BURN.IN = 10000,
#' n_MCMC_chain = 1, ci = 0.95, DTR = TRUE)
#'
#' @return
#' if `interim = TRUE`, this function returns either 0 - no arm is dropped, or A/B/C - arm A/B/C is dropped
#' if `interim = FALSE`, this function returns (comments added to the code, similar to BJSM_binary.R)

#' @references
#' Chao, Y.C., Braun, T.M., Tamura, R.N. and Kidwell, K.M., 2020. A Bayesian group sequential small n sequential multiple‚Äêassignment randomized trial. Journal of the Royal Statistical Society: Series C (Applied Statistics), 69(3), pp.663-680.
#'
#'
group_seq = function(data, rule.type = 1, interim = TRUE, drop_threshold=0.5, drop_threshold_large=0.5, drop_threshold_small=0.5, NUM_ARMS, pi_prior_dist, pi_prior.a,
                     pi_prior.b, beta0_prior_dist, beta0_prior.a, beta0_prior.b, beta1_prior_dist, beta1_prior.a, beta1_prior.c, MCMC_SAMPLE, BURN.IN, n_MCMC_chain, ci = 0.95, DTR = TRUE){

  pi_prior_dist = ifelse(pi_prior_dist == "gamma", "dgamma", ifelse(pi_prior_dist == "beta", "dbeta", "dpar"))
  beta0_prior_dist = ifelse(beta0_prior_dist == "gamma", "dgamma", ifelse(beta0_prior_dist == "beta", "dbeta", "dpar"))
  beta1_prior_dist = ifelse(beta1_prior_dist == "gamma", "dgamma", ifelse(beta1_prior_dist == "beta", "dbeta", "dpar"))


  assn.stage2 <- function(i, trt, y, rand.prob)    # Function that assigns the second stage treatment
  {
    alltrt <- 1:3
    if (y[i]==1) newtrt <- trt[i]
    if (y[i]==0) newtrt <- sample(alltrt[alltrt!=trt[i]], 1, prob=rand.prob[alltrt!=trt[i]])
    return(newtrt)
  }

  if (interim == TRUE){

    file_path <- 'inst'
    jags.model.name.update <- 'Bayes_AR_new.bug'

    pi_hat <- matrix(NA,nrow=n.update,ncol=3)
    patient_entry = data

    patient_entry$disc <- 2 * patient_entry$trt.1st - (patient_entry$resp.1st == 0)

    bugfile  <- readLines("inst/Bayes_AR.bug")
    bugfile  <- gsub(pattern = "pi_prior_dist", replacement = pi_prior_dist, x = bugfile)
    bugfile  <- gsub(pattern = "beta0_prior_dist", replacement = beta0_prior_dist, x = bugfile)
    bugfile2  <- gsub(pattern = "beta1_prior_dist", replacement = beta1_prior_dist, x = bugfile)

    writeLines(bugfile2, con="inst/Bayes_AR_new.bug")

    error_ind <- 0
    tryCatch({
      jags <- rjags::jags.model(file.path(file_path,jags.model.name.update),
                                data=list(n1 = nrow(patient_entry[!is.na(patient_entry$resp.1st),]),
                                          n2 = nrow(patient_entry[!is.na(patient_entry$resp.2nd),]),
                                          num_arms = NUM_ARMS,
                                          Y1 = patient_entry$resp.1st,
                                          Y2 = patient_entry$resp.2nd[!is.na(patient_entry$resp.2nd)],
                                          treatment_stageI = patient_entry$trt.1st,
                                          treatment_stageII = patient_entry$trt.2nd[!is.na(patient_entry$resp.2nd)],
                                          response_stageI_disc = patient_entry$disc[!is.na(patient_entry$resp.2nd)],
                                          #prior
                                          pi_prior.a = pi_prior.a,
                                          pi_prior.b = pi_prior.b,
                                          beta0_prior.a = beta0_prior.a,
                                          beta0_prior.b = beta0_prior.b,
                                          beta1_prior.a = beta1_prior.a,
                                          beta1_prior.c = beta1_prior.c),
                                n.chains=n_MCMC_chain,n.adapt = BURN.IN)
      posterior_sample <- rjags::coda.samples(jags,
                                              c('pi','beta'),
                                              MCMC_SAMPLE)
    },
    warning = function(war){
      warning_count <- warning_count + 1
      err_war_message <- rbind(paste("The warning ", warning_count, " is: ", war))
    },
    error = function(err){
      error_count <- error_count + 1
      err_war_message <- rbind(paste("The error ", error_count, " is: ", err))
      error_ind <- 1
    },
    finally = {
    }
    )
    out_post <- posterior_sample[[1]]

    if (rule.type == 1){
      min_A <- mean(apply(out_post[,7:9],1,function(x) {x[1]==min(x)})) # posterior probability that A has smallest response rate
      min_B <- mean(apply(out_post[,7:9],1,function(x) {x[2]==min(x)})) # posterior probability that B has smallest response rate
      min_C <- mean(apply(out_post[,7:9],1,function(x) {x[3]==min(x)})) # posterior probability that C has smallest response rate
      drop_A <- (min_A>drop_threshold)   # decide if A needs to be removed
      drop_B <- (min_B>drop_threshold)   # decide if B needs to be removed
      drop_C <- (min_C>drop_threshold)   # decide if C needs to be removed
      dropped_arm <- (drop_A==1) * 1 + (drop_B==1) * 2 + (drop_C==1) * 3
      print("Interim Analysis Outcome:")
      if(sum(drop_A,drop_B,drop_C)==0){     # if none of the arm is removed, move on to next update
        print("none of the arm is removed, move on to next update")
      } else if(sum(drop_A,drop_B,drop_C)==1){  # if one of the arms is removed, move on to last assignment
        if (drop_A == 1){
          print("Arm A is dropped")
        } else if (drop_B == 1){
          print("Arm B is dropped")
        } else {
          print("Arm C is dropped")
        }

      }}else{
        min_A <- mean(apply(out_post[,7:9],1,function(x) {x[1]==min(x)}))  # posterior probability that A has smallest response rate
        min_B <- mean(apply(out_post[,7:9],1,function(x) {x[2]==min(x)}))  # posterior probability that B has smallest response rate
        min_C <- mean(apply(out_post[,7:9],1,function(x) {x[3]==min(x)}))  # posterior probability that C has smallest response rate
        max_A <- mean(apply(out_post[,7:9],1,function(x) {x[1]==max(x)}))  # posterior probability that A has largest response rate
        max_B <- mean(apply(out_post[,7:9],1,function(x) {x[2]==max(x)}))  # posterior probability that B has largest response rate
        max_C <- mean(apply(out_post[,7:9],1,function(x) {x[3]==max(x)}))  # posterior probability that C has largest response rate
        keep_A <- (max_A>drop_threshold_large)
        keep_B <- (max_B>drop_threshold_large)
        keep_C <- (max_C>drop_threshold_large)
        if(any(c(keep_A,keep_B,keep_C)>0)){
          drop_A <- ((keep_A==0)*(min_A==max(min_A,min_B,min_C))==1)
          drop_B <- ((keep_B==0)*(min_B==max(min_A,min_B,min_C))==1)
          drop_C <- ((keep_C==0)*(min_C==max(min_A,min_B,min_C))==1)
          if (sum(drop_A,drop_B,drop_C)>1){    # if more than one arm is dropped
            randompick <- sample(1:3,1,prob=c(drop_A,drop_B,drop_C)/sum(drop_A,drop_B,drop_C))
            drop_A <- (randompick==1)
            drop_B <- (randompick==2)
            drop_C <- (randompick==3)
          }
        } else {
          drop_A <- (min_A>drop_threshold_small[k])
          drop_B <- (min_B>drop_threshold_small[k])
          drop_C <- (min_C>drop_threshold_small[k])
        }

        dropped_arm <- (drop_A==1) * 1 + (drop_B==1) * 2 + (drop_C==1) * 3
        print("Interim Analysis Outcome:")

        if(all(c(drop_A,drop_B,drop_C)==0)){     # if none of the arm is dropped, move on to next update
          print("none of the arm is removed, move on to next update")
        } else if(sum(drop_A,drop_B,drop_C)==1){  # if one of the arms is dropped, move on to last assignment
          if (drop_A == 1){
            print("Arm A is dropped")
          } else if (drop_B == 1){
            print("Arm B is dropped")
          } else {
            print("Arm C is dropped")
          }
        }

      }
    return(list("dropped_arm" = dropped_arm))
  } else {

    mydata <- data
    mydata$disc <- 2 * mydata$trt.1st - (mydata$resp.1st == 0)

    bugfile  <- readLines("inst/Bayes.bug")
    bugfile  <- gsub(pattern = "pi_prior_dist", replacement = pi_prior_dist, x = bugfile)
    bugfile  <- gsub(pattern = "beta0_prior_dist", replacement = beta0_prior_dist, x = bugfile)
    bugfile2  <- gsub(pattern = "beta1_prior_dist", replacement = beta1_prior_dist, x = bugfile)

    writeLines(bugfile2, con="inst/Bayes_new.bug")

    jags.model.name <- 'Bayes_new.bug'
    error_ind <- 0
    tryCatch({
      jags <- rjags::jags.model(file.path(file_path,jags.model.name),
                                data=list(n = nrow(mydata),
                                          num_arms = NUM_ARMS,
                                          Y1 = mydata$resp.1st,
                                          Y2 = mydata$resp.2nd,
                                          treatment_stageI = mydata$trt.1st,
                                          treatment_stageII = mydata$trt.2nd,
                                          response_stageI_disc = mydata$disc,
                                          #prior
                                          pi_prior.a = pi_prior.a,
                                          pi_prior.b = pi_prior.b,
                                          beta0_prior.a = beta0_prior.a,
                                          beta0_prior.b = beta0_prior.b,
                                          beta1_prior.a = beta1_prior.a,
                                          beta1_prior.c = beta1_prior.c),
                                n.chains=n_MCMC_chain,n.adapt = BURN.IN)
      posterior_sample <- rjags::coda.samples(jags,
                                              c('pi','beta'),
                                              MCMC_SAMPLE)
    },
    warning = function(war){
      warning_count <- warning_count + 1
      err_war_message <- rbind(paste("The warning ", warning_count, " is: ", war))
    },
    error = function(err){
      error_count <- error_count + 1
      err_war_message <- rbind(paste("The error ", error_count, " is: ", err))
      error_ind <- 1
    }
    )
    out_post <- posterior_sample[[1]]

    pi_DTR_est = c()
    pi_AB_tt <- out_post[,7]^2*out_post[,2]+(1-out_post[,7])*out_post[,8]*out_post[,1]
    pi_AC_tt <- out_post[,7]^2*out_post[,2]+(1-out_post[,7])*out_post[,9]*out_post[,1]
    pi_BA_tt <- out_post[,8]^2*out_post[,4]+(1-out_post[,8])*out_post[,7]*out_post[,3]
    pi_BC_tt <- out_post[,8]^2*out_post[,4]+(1-out_post[,8])*out_post[,9]*out_post[,3]
    pi_CA_tt <- out_post[,9]^2*out_post[,6]+(1-out_post[,9])*out_post[,7]*out_post[,5]
    pi_CB_tt <- out_post[,9]^2*out_post[,6]+(1-out_post[,9])*out_post[,8]*out_post[,5]
    pi_DTR_est <- rbind(pi_DTR_est,c(mean(pi_AB_tt),mean(pi_AC_tt),mean(pi_BA_tt),mean(pi_BC_tt),mean(pi_CA_tt),mean(pi_CB_tt)))

    if (DTR == TRUE){

      final = list("posterior_sample" = out_post, # posterior samples of the link parameters and response rates generated through the MCMC process
                   "pi_hat_bjsm" = apply(out_post[,7:9],2,mean),   # estimate of response rate/treatment effect
                   "se_hat_bjsm" = apply(out_post[,7:9],2,sd),     # standard error of the response rate
                   "ci_pi_A" = bayestestR::ci(out_post[,7], ci = ci, method = "HDI"), # x% credible intervals for A
                   "ci_pi_B" = bayestestR::ci(out_post[,8], ci = ci, method = "HDI"), # x% credible intervals for B
                   "ci_pi_C" = bayestestR::ci(out_post[,9], ci = ci, method = "HDI"), # x% credible intervals for C
                   "diff_AB" = mean(out_post[,7] - out_post[,8]), # estimate of differences between treatments A and B
                   "diff_BC" = mean(out_post[,8] - out_post[,9]), # estimate of differences between treatments B and C
                   "diff_AC" = mean(out_post[,7] - out_post[,9]), # estimate of differences between treatments A and C
                   "ci_diff_AB" = bayestestR::ci(out_post[,7] - out_post[,8], ci = ci, method = "HDI"), # x% credible intervals for the differences between A and B
                   "ci_diff_BC" = bayestestR::ci(out_post[,8] - out_post[,9], ci = ci, method = "HDI"), # x% credible intervals for the differences between B and C
                   "ci_diff_AC" = bayestestR::ci(out_post[,7] - out_post[,9], ci = ci, method = "HDI"), # x% credible intervals for the differences between A and C
                   "beta0_hat" = apply(out_post[,c(1,3,5)],2,mean), # linkage parameter beta0 estimates
                   "beta1_hat" = apply(out_post[,c(2,4,6)],2,mean),  # linkage parameter beta1 estimates
                   "ci_beta0_hat" = HDInterval::hdi(out_post[,c(1,3,5)], ci), # linkage parameter beta0 credible interval
                   "ci_beta1_hat" = HDInterval::hdi(out_post[,c(2,4,6)], ci), # linkage parameter beta1 credible interval
                   "pi_DTR_est" = pi_DTR_est) # expected response rate of dynamic treatment regimens (DTRs)
      return(append(outcome, final))
    }else{
      final = list("posterior_sample" = out_post, # posterior samples of the link parameters and response rates generated through the MCMC process
                   "pi_hat_bjsm" = apply(out_post[,7:9],2,mean),   # estimate of response rate/treatment effect
                   "se_hat_bjsm" = apply(out_post[,7:9],2,sd),     # standard error of the response rate
                   "ci_pi_A" = bayestestR::ci(out_post[,7], ci = ci, method = "HDI"), # x% credible intervals for A
                   "ci_pi_B" = bayestestR::ci(out_post[,8], ci = ci, method = "HDI"), # x% credible intervals for B
                   "ci_pi_C" = bayestestR::ci(out_post[,9], ci = ci, method = "HDI"), # x% credible intervals for C
                   "diff_AB" = mean(out_post[,7] - out_post[,8]), # estimate of differences between treatments A and B
                   "diff_BC" = mean(out_post[,8] - out_post[,9]), # estimate of differences between treatments B and C
                   "diff_AC" = mean(out_post[,7] - out_post[,9]), # estimate of differences between treatments A and C
                   "ci_diff_AB" = bayestestR::ci(out_post[,7] - out_post[,8], ci = ci, method = "HDI"), # x% credible intervals for the differences between A and B
                   "ci_diff_BC" = bayestestR::ci(out_post[,8] - out_post[,9], ci = ci, method = "HDI"), # x% credible intervals for the differences between B and C
                   "ci_diff_AC" = bayestestR::ci(out_post[,7] - out_post[,9], ci = ci, method = "HDI"), # x% credible intervals for the differences between A and C
                   "beta0_hat" = apply(out_post[,c(1,3,5)],2,mean), # linkage parameter beta0 estimates
                   "beta1_hat" = apply(out_post[,c(2,4,6)],2,mean),  # linkage parameter beta1 estimates
                   "ci_beta0_hat" = HDInterval::hdi(out_post[,c(1,3,5)], ci), # linkage parameter beta0 credible interval
                   "ci_beta1_hat" = HDInterval::hdi(out_post[,c(2,4,6)], ci)) # linkage parameter beta1 credible interval
      #    "pi_DTR_est" = pi_DTR_est) # expected response rate of dynamic treatment regimens (DTRs)
      return(append(outcome, final))
    }

  }
}

